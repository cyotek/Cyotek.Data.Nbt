<#@ include file="AutoGenerated.t4" #>
<#+

  const int tagTypeEnd = 0;

  const int tagTypeByte = 1;

  const int tagTypeShort = 2;

  const int tagTypeInt = 3;

  const int tagTypeLong = 4;

  const int tagTypeFloat = 5;

  const int tagTypeDouble = 6;

  const int tagTypeByteArray = 7;

  const int tagTypeString = 8;

  const int tagTypeList = 9;

  const int tagTypeCompound = 10;

  const int tagTypeIntArray = 11;

  string[] nbtTypeNames =
  {
    "End",
    "Byte",
    "Short",
    "Int",
    "Long",
    "Float",
    "Double",
    "ByteArray",
    "String",
    "List",
    "Compound",
    "IntArray"
  };

  string[] secondaryDataTypes =
  {
    "Guid",
    "DateTime",
    "bool"
  };

  string[] secondaryDataTypeMappings =
  {
    "ByteArray",
    "String",
    "Byte"
  };

  string[] secondaryDataTypeMappedTypes =
  {
    "byte[]",
    "string",
    "byte"
  };

  object[] secondaryDataTypeTestData =
  {
    "new Guid(\"{52C1F966-496F-4802-841D-9E5579C86706}\")",
    "new DateTime(2016, 12, 27, 21, 06, 00)",
    "true"
  };

  object[] secondaryDataTypeTranslatedTestData =
  {
    "new byte[] {102, 249, 193, 82, 111, 73, 2, 72, 132, 29, 158, 85, 121, 200, 103, 6 }",
    "\"2016-12-27 21:06:00Z\"",
    "(byte)1"
  };

  string[] nbtTagTypeNames =
  {
    "TagEnd",
    "TagByte",
    "TagShort",
    "TagInt",
    "TagLong",
    "TagFloat",
    "TagDouble",
    "TagByteArray",
    "TagString",
    "TagList",
    "TagCompound",
    "TagIntArray"
  };

  string[] netTypeNames =
  {
    null,
    "byte",
    "short",
    "int",
    "long",
    "float",
    "double",
    "byte[]",
    "string",
    "TagCollection",
    "TagDictionary",
    "int[]"
  };

  object[] defaultValues =
  {
    null,
    default(byte),
    default(short),
    default(int),
    default(long),
    default(float),
    default(double),
    "new byte[0]",
    default(string),
    "new TagCollection()",
    "new TagDictionary()",
    "new int[0]"
  };

  string[] objectConversions =
  {
    null,
    "Convert.ToByte(value)",
    "Convert.ToInt16(value)",
    "Convert.ToInt32(value)",
    "Convert.ToInt64(value)",
    "Convert.ToSingle(value)",
    "Convert.ToDouble(value)",
    "(byte[])value",
    "Convert.ToString(value)",
    "(TagCollection)value ?? new TagCollection()",
    "(TagDictionary)value ?? new TagDictionary()",
    "(int[])value"
  };

  string[] nbtTypeDescriptions =
  {
    "Used to mark the end of a list",
    "A single signed byte",
    "A signed 16bit short",
    "A signed 32bit integer",
    "A signed 64bit long",
    "A 32bit floating point value",
    "A 64bit floating point value",
    "An array of bytes of unspecified format",
    "An array of bytes defining a string in UTF-8 format",
    "A sequential list of unnamed tags of a specific type",
    "A sequential list of named tags of variable types",
    "An array of integers of unspecified format"
  };

  object[] tagTestData =
  {
    null,
    byte.MaxValue >> 1,
    short.MaxValue >> 1,
    int.MaxValue >> 1,
    long.MaxValue >> 1,
    float.MaxValue / 2 + "F",
    double.MaxValue / 2,
    "new byte[] { 2, 4, 8, 16, 32, 64, 128 }",
    "\"HELLO WORLD THIS IS A TEST STRING ÅÄÖ!\"",
    "new TagCollection(TagType.Int) { 2, 4, 8, 16, 32, 64, 128, 256 }",
    "new TagDictionary { new TagByte(\"A\", 2), new TagShort(\"B\", 4), new TagInt(\"C\", 8) }",
    "new[] { 2190, 2994, 3248, 4294394 }"
  };

  object[] altTagTestData =
  {
    null,
    byte.MaxValue >> 2,
    short.MaxValue >> 2,
    int.MaxValue >> 2,
    long.MaxValue >> 2,
    float.MaxValue / 3 + "F",
    double.MaxValue / 3,
    "new byte[] { 2, 4, 8, 16, 32, 48, 128 }",
    "\"DIFFERENT\"",
    "new TagCollection(TagType.Int) { 2, 4, 8, 16, 32, 64, 128, 255 }",
    "new TagDictionary { new TagByte(\"A\", 2), new TagShort(\"B\", 4), new TagInt(\"C\", 16) }",
    "new[] { 2190, 2994, 3248, 294394 }"
  };

  private bool IsArrayType(int type)
  {
    return type == tagTypeByteArray || type == tagTypeIntArray;
  }

  private bool IsListType(int type)
  {
    return type == tagTypeList;
  }

  #>
